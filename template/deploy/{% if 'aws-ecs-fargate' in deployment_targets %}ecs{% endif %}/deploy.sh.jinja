#!/usr/bin/env bash
set -euo pipefail

# ECS Fargate Deployment Script for {{ project_name }}
# This script handles the complete deployment process to AWS ECS Fargate

# Color output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
PROJECT_NAME="{{ project_slug }}"
AWS_REGION="${AWS_REGION:-us-east-1}"
ENVIRONMENT="${ENVIRONMENT:-production}"
TERRAFORM_DIR="./deploy/ecs/terraform"
IMAGE_TAG="${IMAGE_TAG:-latest}"

# Functions
print_status() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
    exit 1
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_prompt() {
    echo -e "${BLUE}[INPUT]${NC} $1"
}

# Check dependencies
check_dependencies() {
    print_status "Checking dependencies..."

    local missing_deps=()

    if ! command -v aws &> /dev/null; then
        missing_deps+=("aws-cli")
    fi

    if ! command -v terraform &> /dev/null; then
        missing_deps+=("terraform")
    fi

    if ! command -v docker &> /dev/null; then
        missing_deps+=("docker")
    fi

    if ! command -v jq &> /dev/null; then
        missing_deps+=("jq")
    fi
{% raw %}
    if [ ${#missing_deps[@]} -gt 0 ]; then
        print_error "Missing dependencies: ${missing_deps[*]}"
    fi
{% endraw %}
    print_status "All dependencies found"
}

# Check AWS credentials
check_aws_credentials() {
    print_status "Checking AWS credentials..."

    if ! aws sts get-caller-identity &> /dev/null; then
        print_error "AWS credentials not configured. Run: aws configure"
    fi

    AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
    print_status "AWS Account: $AWS_ACCOUNT_ID"
}

# Initialize Terraform
init_terraform() {
    print_status "Initializing Terraform..."

    cd "$TERRAFORM_DIR"

    # Initialize with backend config if S3 backend is used
    if grep -q "backend \"s3\"" main.tf; then
        BACKEND_BUCKET="${PROJECT_NAME}-terraform-state-${AWS_ACCOUNT_ID}"

        # Create S3 bucket for state if it doesn't exist
        if ! aws s3api head-bucket --bucket "$BACKEND_BUCKET" 2>/dev/null; then
            print_status "Creating S3 bucket for Terraform state..."
            aws s3api create-bucket \
                --bucket "$BACKEND_BUCKET" \
                --region "$AWS_REGION" \
                $([ "$AWS_REGION" != "us-east-1" ] && echo "--create-bucket-configuration LocationConstraint=$AWS_REGION" || echo "")

            # Enable versioning
            aws s3api put-bucket-versioning \
                --bucket "$BACKEND_BUCKET" \
                --versioning-configuration Status=Enabled

            # Enable encryption
            aws s3api put-bucket-encryption \
                --bucket "$BACKEND_BUCKET" \
                --server-side-encryption-configuration '{"Rules": [{"ApplyServerSideEncryptionByDefault": {"SSEAlgorithm": "AES256"}}]}'
        fi

        terraform init \
            -backend-config="bucket=$BACKEND_BUCKET" \
            -backend-config="key=ecs-fargate/terraform.tfstate" \
            -backend-config="region=$AWS_REGION"
    else
        terraform init
    fi

    cd - > /dev/null
    print_status "Terraform initialized"
}

# Get or create ECR repository
get_ecr_repository() {
    print_status "Getting ECR repository..."

    # First check if Terraform already created the repository
    ECR_REPO_NAME="${PROJECT_NAME}-${ENVIRONMENT}"

    # Try to get repository URL from Terraform output first
    if [ -d "$TERRAFORM_DIR" ] && [ -f "$TERRAFORM_DIR/terraform.tfstate" ]; then
        cd "$TERRAFORM_DIR"
        ECR_URI=$(terraform output -raw ecr_repository_url 2>/dev/null || echo "")
        cd - > /dev/null

        if [ -n "$ECR_URI" ]; then
            print_status "Using ECR repository from Terraform: $ECR_URI"
            return
        fi
    fi

    # If not found in Terraform, check if it exists in AWS
    if aws ecr describe-repositories --repository-names "$ECR_REPO_NAME" --region "$AWS_REGION" &> /dev/null; then
        ECR_URI=$(aws ecr describe-repositories \
            --repository-names "$ECR_REPO_NAME" \
            --region "$AWS_REGION" \
            --query "repositories[0].repositoryUri" \
            --output text)
        print_status "Found existing ECR repository: $ECR_URI"
    else
        print_warning "ECR repository not found. It will be created by Terraform during deployment."
        print_status "Run infrastructure deployment first, or the repository will be created automatically."
        ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME}"
    fi
}

# Build Docker image
build_docker_image() {
    print_status "Building Docker image..."

    # Check if Dockerfile exists
    if [ ! -f "Dockerfile" ]; then
        print_error "Dockerfile not found in current directory"
    fi

    docker build \
        --platform linux/amd64 \
        --tag "${PROJECT_NAME}:${IMAGE_TAG}" \
        --build-arg ENVIRONMENT="$ENVIRONMENT" \
        .

    print_status "Docker image built successfully"
}

# Push to ECR
push_to_ecr() {
    print_status "Pushing image to ECR..."

    # Login to ECR
    aws ecr get-login-password --region "$AWS_REGION" | \
        docker login --username AWS --password-stdin "$ECR_URI"

    # Tag image
    docker tag "${PROJECT_NAME}:${IMAGE_TAG}" "${ECR_URI}:${IMAGE_TAG}"
    docker tag "${PROJECT_NAME}:${IMAGE_TAG}" "${ECR_URI}:latest"

    # Push image
    docker push "${ECR_URI}:${IMAGE_TAG}"
    docker push "${ECR_URI}:latest"

    print_status "Image pushed to ECR"
}

# Generate Terraform variables
generate_tfvars() {
    print_status "Generating Terraform variables..."

    local tfvars_file="${TERRAFORM_DIR}/terraform.tfvars"

    if [ -f "$tfvars_file" ]; then
        print_warning "terraform.tfvars already exists"
        print_prompt "Overwrite? (y/n):"
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            return
        fi
    fi

    # Generate Django secret key
    DJANGO_SECRET_KEY=$(python3 -c 'from django.core.management.utils import get_random_secret_key; print(get_random_secret_key())')

    cat > "$tfvars_file" << EOF
# Terraform variables for ${PROJECT_NAME} ${ENVIRONMENT}
# Generated on $(date)

project_name     = "${PROJECT_NAME}"
environment      = "${ENVIRONMENT}"
aws_region       = "${AWS_REGION}"
# container_image is automatically set from ECR repository created by Terraform
# Uncomment and set only if using an external image:
# container_image  = "${ECR_URI}:latest"

# Django configuration
django_secret_key = "${DJANGO_SECRET_KEY}"
django_debug      = false
allowed_hosts     = "${PROJECT_NAME}.${AWS_REGION}.elb.amazonaws.com"

# Container resources
container_cpu    = $([ "$ENVIRONMENT" = "production" ] && echo "1024" || echo "512")
container_memory = $([ "$ENVIRONMENT" = "production" ] && echo "2048" || echo "1024")

# Auto-scaling
desired_count = $([ "$ENVIRONMENT" = "production" ] && echo "2" || echo "1")
min_capacity  = $([ "$ENVIRONMENT" = "production" ] && echo "2" || echo "1")
max_capacity  = $([ "$ENVIRONMENT" = "production" ] && echo "10" || echo "3")

# Database
use_aurora_serverless = $([ "$ENVIRONMENT" = "production" ] && echo "true" || echo "false")
db_instance_class     = "db.t3.micro"
db_deletion_protection = $([ "$ENVIRONMENT" = "production" ] && echo "true" || echo "false")

# Monitoring
enable_monitoring = $([ "$ENVIRONMENT" = "production" ] && echo "true" || echo "false")
alarm_email      = ""  # Add your email for CloudWatch alarms

# Cost optimization
enable_spot_capacity = $([ "$ENVIRONMENT" != "production" ] && echo "true" || echo "false")

{% if cache == 'redis' -%}
# Redis
enable_redis = true
redis_node_type = "cache.t3.micro"
{% endif %}

{% if use_celery -%}
# Celery
enable_celery = true
celery_worker_count = $([ "$ENVIRONMENT" = "production" ] && echo "2" || echo "1")
{% endif %}

# Additional tags
additional_tags = {
  DeployedBy = "Terraform"
  DeployedAt = "$(date -u +%Y-%m-%d_%H:%M:%S)"
}
EOF

    chmod 600 "$tfvars_file"
    print_status "Variables file created: $tfvars_file"
    print_warning "Please review and update the variables as needed"
}

# Deploy with Terraform
deploy_terraform() {
    print_status "Deploying infrastructure with Terraform..."

    cd "$TERRAFORM_DIR"

    # Validate configuration
    print_status "Validating Terraform configuration..."
    terraform validate

    # Plan deployment
    print_status "Planning deployment..."
    terraform plan -out=tfplan

    # Show plan summary
    terraform show -no-color tfplan | grep -E "^  # |^Plan:"

    print_prompt "Do you want to apply this plan? (yes/no):"
    read -r response

    if [ "$response" != "yes" ]; then
        print_status "Deployment cancelled"
        rm tfplan
        return 1
    fi

    # Apply plan
    print_status "Applying Terraform plan..."
    terraform apply tfplan

    rm tfplan
    cd - > /dev/null

    print_status "Infrastructure deployed successfully"
}

# Run database migrations
run_migrations() {
    print_status "Running database migrations..."

    local cluster_name="${PROJECT_NAME}-${ENVIRONMENT}-cluster"
    local task_family="${PROJECT_NAME}-${ENVIRONMENT}-migrate"

    # Get migration task definition ARN from Terraform
    cd "$TERRAFORM_DIR"
    local task_def_arn=$(terraform output -raw ecs_migrate_task_definition 2>/dev/null)
    cd - > /dev/null

    if [ -z "$task_def_arn" ] || [ "$task_def_arn" = "null" ]; then
        print_error "Migration task definition not found. Run 'deploy infrastructure' first."
    fi

    # Get subnet and security group information
    local subnet_ids=$(aws ec2 describe-subnets \
        --filters "Name=tag:Project,Values=${PROJECT_NAME}" "Name=tag:Type,Values=Private" \
        --query "Subnets[*].SubnetId" \
        --output json | jq -r '. | join(",")')
    local security_group=$(aws ec2 describe-security-groups \
        --filters "Name=tag:Project,Values=${PROJECT_NAME}" "Name=group-name,Values=${PROJECT_NAME}-${ENVIRONMENT}-app-*" \
        --query "SecurityGroups[0].GroupId" \
        --output text)

    # Run migration task
    print_status "Running migration task..."
    local task_arn=$(aws ecs run-task \
        --cluster "$cluster_name" \
        --task-definition "$task_def_arn" \
        --launch-type FARGATE \
        --network-configuration "awsvpcConfiguration={subnets=[$subnet_ids],securityGroups=[$security_group],assignPublicIp=DISABLED}" \
        --query "tasks[0].taskArn" \
        --output text)

    print_status "Migration task started: $task_arn"

    # Wait for migration to complete
    print_status "Waiting for migration to complete..."
    aws ecs wait tasks-stopped \
        --cluster "$cluster_name" \
        --tasks "$task_arn"

    # Check exit code
    local exit_code=$(aws ecs describe-tasks \
        --cluster "$cluster_name" \
        --tasks "$task_arn" \
        --query "tasks[0].containers[0].exitCode" \
        --output text)

    if [ "$exit_code" = "0" ]; then
        print_status "Migrations completed successfully"
    else
        print_error "Migrations failed with exit code: $exit_code"
    fi
}

# Update ECS service
update_ecs_service() {
    print_status "Updating ECS service..."

    local cluster_name="${PROJECT_NAME}-${ENVIRONMENT}-cluster"
    local service_name="${PROJECT_NAME}-${ENVIRONMENT}-app"

    aws ecs update-service \
        --cluster "$cluster_name" \
        --service "$service_name" \
        --force-new-deployment \
        --region "$AWS_REGION"

    print_status "ECS service update initiated"

    # Wait for service to stabilize
    print_status "Waiting for service to stabilize..."
    aws ecs wait services-stable \
        --cluster "$cluster_name" \
        --services "$service_name" \
        --region "$AWS_REGION"

    print_status "Service deployed successfully"
}

# Show deployment info
show_deployment_info() {
    print_status "Deployment Information:"
    echo "======================================"

    cd "$TERRAFORM_DIR"

    # Get outputs
    local alb_url=$(terraform output -raw alb_url 2>/dev/null || echo "N/A")
    local ecr_url=$(terraform output -raw ecr_repository_url 2>/dev/null || echo "N/A")
    local log_group=$(terraform output -raw cloudwatch_log_group 2>/dev/null || echo "N/A")

    cd - > /dev/null

    echo "Application URL: $alb_url"
    echo "ECR Repository: $ecr_url"
    echo "CloudWatch Logs: $log_group"
    echo ""
    echo "Useful commands:"
    echo "  View logs:        aws logs tail $log_group --follow"
    echo "  Scale service:    aws ecs update-service --cluster ${PROJECT_NAME}-${ENVIRONMENT}-cluster --service ${PROJECT_NAME}-${ENVIRONMENT}-app --desired-count 3"
    echo "  SSH to task:      aws ecs execute-command --cluster ${PROJECT_NAME}-${ENVIRONMENT}-cluster --task <task-id> --container ${PROJECT_NAME} --interactive --command /bin/bash"
    echo "======================================"
}

# Rollback deployment
rollback() {
    print_warning "Rolling back deployment..."

    local cluster_name="${PROJECT_NAME}-${ENVIRONMENT}-cluster"
    local service_name="${PROJECT_NAME}-${ENVIRONMENT}-app"

    # Get previous task definition
    local prev_task_def=$(aws ecs describe-services \
        --cluster "$cluster_name" \
        --services "$service_name" \
        --query "services[0].deployments[1].taskDefinition" \
        --output text)

    if [ "$prev_task_def" != "null" ] && [ -n "$prev_task_def" ]; then
        aws ecs update-service \
            --cluster "$cluster_name" \
            --service "$service_name" \
            --task-definition "$prev_task_def" \
            --force-new-deployment

        print_status "Rollback initiated to: $prev_task_def"
    else
        print_error "No previous deployment found to rollback to"
    fi
}

# Main menu
show_menu() {
    echo "======================================"
    echo "ECS Fargate Deployment for {{ project_name }}"
    echo "Environment: $ENVIRONMENT"
    echo "Region: $AWS_REGION"
    echo "======================================"
    echo ""
    echo "1. Full deployment (build, push, deploy)"
    echo "2. Build and push Docker image only"
    echo "3. Deploy infrastructure only"
    echo "4. Update ECS service"
    echo "5. Run database migrations"
    echo "6. Show deployment info"
    echo "7. Generate terraform.tfvars"
    echo "8. Rollback deployment"
    echo "9. Destroy infrastructure"
    echo "10. Exit"
    echo ""
    print_prompt "Select option (1-10):"
}

# Full deployment
full_deployment() {
    check_dependencies
    check_aws_credentials
    init_terraform

    # Deploy infrastructure first (which creates ECR)
    if [ ! -f "${TERRAFORM_DIR}/terraform.tfvars" ]; then
        generate_tfvars
    fi

    deploy_terraform

    # Now build and push to the ECR created by Terraform
    get_ecr_repository
    build_docker_image
    push_to_ecr

    # Update service with new image
    update_ecs_service
    run_migrations
    show_deployment_info
}

# Destroy infrastructure
destroy_infrastructure() {
    print_warning "This will destroy all infrastructure!"
    print_prompt "Type 'DESTROY' to confirm:"
    read -r confirmation

    if [ "$confirmation" != "DESTROY" ]; then
        print_status "Destruction cancelled"
        return
    fi

    cd "$TERRAFORM_DIR"
    terraform destroy
    cd - > /dev/null
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --environment|-e)
            ENVIRONMENT="$2"
            shift 2
            ;;
        --region|-r)
            AWS_REGION="$2"
            shift 2
            ;;
        --image-tag|-t)
            IMAGE_TAG="$2"
            shift 2
            ;;
        --auto|-y)
            AUTO_APPROVE=true
            shift
            ;;
        --help|-h)
            echo "Usage: $0 [options]"
            echo ""
            echo "Options:"
            echo "  -e, --environment ENV    Environment (dev/staging/production)"
            echo "  -r, --region REGION      AWS region"
            echo "  -t, --image-tag TAG      Docker image tag"
            echo "  -y, --auto               Auto approve all prompts"
            echo "  -h, --help               Show this help message"
            exit 0
            ;;
        *)
            print_error "Unknown option: $1"
            ;;
    esac
done

# Main execution
if [ "${AUTO_APPROVE:-false}" = true ]; then
    full_deployment
else
    while true; do
        show_menu
        read -r option

        case $option in
            1) full_deployment ;;
            2)
                check_dependencies
                check_aws_credentials
                get_ecr_repository
                build_docker_image
                push_to_ecr
                ;;
            3)
                check_dependencies
                check_aws_credentials
                init_terraform
                deploy_terraform
                ;;
            4) update_ecs_service ;;
            5) run_migrations ;;
            6) show_deployment_info ;;
            7) generate_tfvars ;;
            8) rollback ;;
            9) destroy_infrastructure ;;
            10) exit 0 ;;
            *) print_error "Invalid option" ;;
        esac

        echo ""
        print_prompt "Press any key to continue..."
        read -n 1 -s
        echo ""
    done
fi
